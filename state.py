"""
THIS CODE WAS GENERATED BY AI.
"""

import copy

class State:
    def __init__(self):
        self.total_games = 0
        self.reset()

    def reset(self):
        self.current_player = 'X'  # X always starts
        self.board = [[[' ' for _ in range(3)] for _ in range(3)] for _ in range(9)]
        self.big_board = [' ' for _ in range(9)]
        self.winner = None
        self.last_move = None

    def apply_move(self, move):
        b, (row, col) = move
        if self.board[b][row][col] == ' ':
            self.board[b][row][col] = self.current_player
            if self.check_small_winner(self.board[b]) is not None:
                self.big_board[b] = self.current_player
            self.last_move = (b, row, col)
            self.current_player = 'O' if self.current_player == 'X' else 'X'
        else:
            raise ValueError("Invalid move")

    def check_small_winner(self, board):
        return self.check_winner(board, mode="2D")

    def check_big_winner(self):
        return self.check_winner(self.big_board, mode="1D")
    
    def get_next_state(self, action):
        # Create a deep copy of the current state to avoid mutating it
        new_state = copy.deepcopy(self)
        # Apply the move to the new state
        new_state.apply_move(action)
        # Return the new state
        return new_state

    def check_winner(self, board, mode="2D"):
        lines = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8],  # Horizontal
            [0, 3, 6], [1, 4, 7], [2, 5, 8],  # Vertical
            [0, 4, 8], [2, 4, 6]             # Diagonal
        ]
        for line in lines:
            if mode == "2D":
                # Unpack the indices properly for 2D mode
                if board[line[0]//3][line[0]%3] == board[line[1]//3][line[1]%3] == board[line[2]//3][line[2]%3] != ' ':
                    return board[line[0]//3][line[0]%3]
            else:
                # Direct access for 1D mode
                if board[line[0]] == board[line[1]] == board[line[2]] != ' ':
                    return board[line[0]]
        return None

    def is_terminal(self):
        # Check for a winner on the big board
        big_winner = self.check_big_winner()
        if big_winner is not None:
            return True, big_winner

        # Check if there are any legal moves left
        if not self.get_legal_actions():  # No legal moves available
            return True, 'Draw'

        return False, None
    
    def get_legal_actions(self):
        legal_moves = []
        if self.last_move is None:
            target_boards = range(9)  # First move can go anywhere
        else:
            # Calculate the index of the target sub-board
            target_board_index = 3 * (self.last_move[1] % 3) + self.last_move[2] % 3
            # Check if the target sub-board is already won or full
            if self.big_board[target_board_index] != ' ' or self.is_full(self.board[target_board_index]):
                # If yes, allow moves in any other available board
                target_boards = [i for i in range(9) if self.big_board[i] == ' ' and not self.is_full(self.board[i])]
            else:
                # Otherwise, they must play in the specified sub-board
                target_boards = [target_board_index]

        for b in target_boards:
            for row in range(3):
                for col in range(3):
                    if self.board[b][row][col] == ' ':
                        legal_moves.append((b, (row, col)))

        return legal_moves

    def is_full(self, board):
        # Check if all cells in the board are filled
        return all(cell != ' ' for row in board for cell in row)

        
    def print_board(self):
        for big_row in range(3):
            for small_row in range(3):
                row_to_print = []
                for big_col in range(3):
                    board_index = big_row * 3 + big_col
                    row_to_print.extend(self.board[board_index][small_row])
                    row_to_print.append("|")
                print(' '.join(row_to_print[:-1]))
            if big_row < 2:
                print("-" * 29) 

    def __repr__(self):
        # Optional: For debug display of the board
        return '\n'.join([' '.join(row) for subboard in self.board for row in subboard])
